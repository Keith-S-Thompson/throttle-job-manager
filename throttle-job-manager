#!/usr/bin/perl -w

# $Id: throttle-job-manager,v 1.7 2003-09-10 15:15:10-07 kst Exp $
# $Source: /home/kst/CVS_smov/tools/throttle-job-manager/throttle-job-manager,v $

########################################################################
# @Copyright@
#
# Copyright (c) 2003 The Regents of the University of California. All
# rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are
# met:
#
# 1. Redistributions of source code must retain the above copyright
# notice, this list of conditions and the following disclaimer.
#
# 2. Redistributions in binary form must reproduce the above copyright
# notice, this list of conditions and the following disclaimer in the
# documentation and/or other materials provided with the distribution.
#
# 3. All advertising materials mentioning features or use of this
# software must display the following acknowledgement: This product
# includes software developed by the Grid and Cluster Computing Group
# at the San Diego Supercomputer Center and its contributors.
#
# 4. Neither the name of the Center nor the names of its contributors
# may be used to endorse or promote products derived from this software
# without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS''
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
# THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
# PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS
# BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
# BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
# OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
# IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#
# @Copyright@
########################################################################

########################################################################
# Developed by Keith Thompson <kst@sdsc.edu>
########################################################################

use strict;

use File::Basename ();
use Getopt::Long ();

sub Get_Processes($);
sub Usage(@);
sub Debug(@);

$| = 1;

my $Program_Name = File::Basename::basename $0;

die "$Program_Name: No directory /proc\n" if not -d "/proc";
die "$Program_Name: No Linux-style /proc directory\n" if not -e "/proc/$$/stat";

my $User_Opt = { max      => 10,
                 interval => 60,
                 name     => 'globus-job-manager' };
my @Opts = ( $User_Opt, qw( help max=i interval=i debugging ) );
Getopt::Long::GetOptions @Opts or Usage;
Usage if $User_Opt->{help};

Debug "max  = $User_Opt->{max}\n";
Debug "name = $User_Opt->{name}\n";

my $pattern = "/\Q$User_Opt->{name}\E\$";
eval '$pattern = qr/$pattern/';
Debug "pattern = $pattern\n";

#
# One problem I ran into: a globus-job-manager process invokes another
# program by the usual fork/exec.  The process forks, and we pick
# up the child process before it execs (while it still shows up as a
# globus-job-manager process).  We send it a STOP signal.  Next time
# around, it's no longer a globus-job-manager process, so we ignore
# it, and we never send it a CONT signal.
#
# Solution: Set the is_new attribute and ignore processes the first
# time we see them.  (This could also allow short-running job managers
# to complete.)
#

#
# $Proc is a reference to a hash keyed by PIDs, containing information
# about all known globus-job-manager processes.
#
# Each value is a hash reference with the following fields:
#     pid         The numeric process id (redundant with the key).
#     state       One character from the string "RSDZTW" where R is
#                 running,  S is sleeping in an interruptible wait,
#                 D is waiting in uninterruptible disk sleep, Z  is
#                 zombie, T is traced or stopped (on a signal), and
#                 W is paging.  (Wording stolen from proc(5) man page.)
#     stop_time   A timestamp indicating when we last sent the process a
#                 STOP signal; not defined if the process is not currently
#                 stopped.
#     start_time  A timestamp indicating when we last sent the process a
#                 CONT signal; not defined if the process is currently
#                 stopped, or if we've never stopped it.
#     is_new      True if this is the first time we've seen this process.
#                 New processes are ignored.
#
my $Proc = {};

while (1) {
    sleep $User_Opt->{interval} - time % $User_Opt->{interval};
    my $processes = Get_Processes $pattern;

    #
    # Delete nonexistent processes from $Proc.
    # (I'm not sure whether it's safe to delete elements within a foreach,
    # so first build the list, then delete the elements.)
    #
    my @dead = ();
    foreach my $pid (keys %$Proc) {
        push @dead, $pid if not defined $processes->{$pid};
    }
    foreach my $pid (@dead) {
        delete $Proc->{$pid};
    }

    print "time: ", time, "\n";
    print "updates: ";
    #
    # Update $Proc
    #
    foreach my $pid (keys %$processes) {
        my $old_state = $Proc->{$pid}->{state};
        my $new_state = $processes->{$pid};
        $Proc->{$pid}->{state} = $new_state;
        if (not defined $old_state) {
            print "$pid --> $new_state ";
            #
            # New process; set start_time to now.
            #
            $Proc->{$pid}->{start_time} = time;
            $Proc->{$pid}->{is_new} = 1;
        }
        else {
            if ($old_state ne $new_state) {
                print "$pid $old_state --> $new_state ";
            }
            delete $Proc->{$pid}->{is_new};
        }
    }
    print "\n";

    my @sorted_processes = sort By_Runnability keys %$processes;
    print "status: ";
    foreach my $pid (@sorted_processes) {
        print "$pid $Proc->{$pid}->{state} ";
    }
    print "\n";
    my @stop_targets = ();
    my @cont_targets = ();
    for (my $i = 0; $i <= $#sorted_processes; $i ++) {
        my $pid = $sorted_processes[$i];
        next if $Proc->{$pid}->{is_new};
        if ($#sorted_processes - $i < $User_Opt->{max}) {
            #
            # If it's stopped, restart it.
            #
            if ($Proc->{$pid}->{state} eq 'T') {
                push @cont_targets, $pid;
                $Proc->{$pid}->{start_time} = time;
            }
        }
        else {
            #
            # If it's running, stop it.
            #
            if ($Proc->{$pid}->{state} ne 'T') {
                push @stop_targets, $pid;
                $Proc->{$pid}->{stop_time} = time;
            }
        }
    }
    if (@stop_targets) {
        print "kill -STOP @stop_targets\n";
        kill 'STOP', @stop_targets;
    }
    if (@cont_targets) {
        print "kill -CONT @cont_targets\n";
        kill 'CONT', @cont_targets;
    }
    print "\n";
}

########################################################################

#
# Returns a reference to a hash, keyed by pids.
# Hash values are the "state", as defined above.
#
sub Get_Processes($) {
    my($exe_pat) = @_;

    #
    # Get a list of all current processes
    #
    opendir PROC, '/proc' or die "/proc: $!\n";
    my @pids = sort { $a <=> $b } grep /^\d+$/, readdir PROC;
    closedir PROC;

    my $result = {};
    PROCESS:
    foreach my $pid (@pids) {
        my $exe = readlink "/proc/$pid/exe";
        next if not defined $exe;
        next if $exe !~ /$exe_pat/;

        open STAT, "/proc/$pid/stat" or next PROCESS;
        my $line = <STAT>;
        close STAT;
        my ($state) = ($line =~ /^\d+ \(.*\) (.)/);
        $result->{$pid} = $state;
    }
    return $result;
} # Get_Processes

# ----------------------------------------------------------------------

#
# Compare processes $a and $b for "runnability".  Processes with the
# lowest runnability are candidates for being sent a STOP signal (or
# not being sent a CONT signal if they're already stopped).
#
# First, procesess that are currently stopped (state 'T') are more
# runnable than processes that are not currently stopped.
#
# Second, if two processes are both stopped, the one has been stopped for
# the longest time is more runnable; or if two processes are both running,
# the one that has been running for the longest time is *less* runnable.
#
# Third, punt and compare the numeric PIDs.
# 
sub By_Runnability {
    my $a_stopped = ( $Proc->{$a}->{state} eq 'T' ? 1 : 0 );
    my $b_stopped = ( $Proc->{$b}->{state} eq 'T' ? 1 : 0 );

#   Debug "By_Runnability comparing $a ",
#         $a_stopped ? "stopped" : "not stopped",
#         " vs. $b ",
#         $b_stopped ? "stopped" : "not stopped",
#         "\n";

    if ($a_stopped and not $b_stopped) {
#       Debug "return 1\n";
        return 1;
    }
    elsif (not $a_stopped and $b_stopped) {
#       Debug "return -1\n";
        return -1;
    }
    elsif ($a_stopped and defined $Proc->{$a}->{stop_time} and
           $b_stopped and defined $Proc->{$b}->{stop_time})
    {
#       Debug "Comparing stop_time, then PID\n";
        return $Proc->{$b}->{stop_time} <=> $Proc->{$a}->{stop_time} ||
               $a <=> $b
    }
    elsif (not $a_stopped and defined $Proc->{$a}->{start_time} and
           not $b_stopped and defined $Proc->{$b}->{start_time})
    {
#       Debug "Comparing start_time, then PID\n";
        return $Proc->{$a}->{start_time} <=> $Proc->{$b}->{start_time} ||
               $a <=> $b;
    }
    else {
#       Debug "Comparing PID\n";
        return $a <=> $b;
    }
} # By_Runnability 

# ----------------------------------------------------------------------

sub Debug(@) {
    print @_ if $User_Opt->{debugging};
} # Debug

# ----------------------------------------------------------------------

sub Usage(@) {
    print @_ if @_;
    print <<"EOF";
Usage: $Program_Name [options]
    -help               Display this message and exit
    -max num            Maximum number of running processes; default is 10
    -interval seconds   Seconds between queries; default is 60
    -name string        Name of executable to throttle;
                        default is "globus-job-manager"
    -debugging          Enable debugging output
EOF
    exit 1;
} # Usage
